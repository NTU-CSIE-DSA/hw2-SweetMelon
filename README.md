# DSA 2023 HW2 - Everyone Loves Sweet melons

## Tutorial

First, we know that the company structure is a tree. And what we want to do is to find the cheapest element on each node and use them to calculate the total cost of each subtree. Finally, we can get the largest subtree with the total cost less than constraint $C$.

### One melon on each node

Let's assume that there is only one melon on each node. Then how can we find the total cost of each subtree? A naive method is to traverse all descendants of each node. But it's too slow. Instead, we know that for the subtree of one node, the total cost is its cost add the sum of the total cost of the subtree of its all children. Hence, for each node, all we need to do is to calculate the total cost of each child and use the result to update it.

### Mutiple melon on each node

Of course, we want to buy the cheapest melon. Hence, it is important for us to find the cheapest melon on each node quickly. It's okay to just remove the old melon when we get the cheaper one. But it isn't suitable when we consider the event duration. Here we use heap one each node to maintain the cheapest melon on each node. The reason will be explained below.

### Event with duration

How to remove outdated events on each node? Checking all events seems too slow. However, is it necessary to check all events? It's clear that we just care about the cheapest one. Hence, we only want to know whether the cheapest melon is outdated. Here is the reason why we need to use heap to maintain the cheapest melon. Because when the cheapest one is outdated we want to find the new cheapest one to replace, heap is suitable for operations like this.

### Solution

Every day on each node, push the new data into the heap, then pop the top until the top isn't outdated. After updating all nodes, just traverse the whole tree to calculate the cost of them and get the answer.

### Complexity

Time Complexity:

$M$ day $\times$ $N$ node $\times$ operation on heap is $\log M$ = $O(NM\log{M})$

Space Complexity:

$N$ node $\times$ heap with size $M$ = $O(NM)$

## Coding Tip

It's exhausting to maintain a heap by pointer. Hence using something like malloc to allocate continuous memory to store the heap make this question easier a lot.

There are a lot of ways to traverse the whole tree in this problem, the method I use in the sample code is dfs. But I trust it is easier a lot with using topologic sort order if you know what it is.

## Sample code

[Source Code](./solution/ac2.c)

## Testdata
Generated by [TPS](https://github.com/ioi-2017/tps)
```
# generate testdata
tps gen
```
